---
title : "가상 메모리(Virtual Memory)"
excerpt : "운영체제 : 가상 메모리"
use_math : true
categories :
  - 운영체제

---

> 가상 메모리(Virtual Memory)  

메인 메모리의 크기가 한정되어 있기 때문에 물리적인 메모리 크기보다 크기가 큰 프로세스를 실행시킬 수 없다. 예를 들어 1GB 메인 메모리에선 2GB 크기의 프로세스를 실행할 수 없다.  

사실 프로세스의 모든 코드는 항상 필요한 것은 아니다. 프로세스는 **필요한 부분만 메모리에 적재하여 메모리에 올라가는 프로세스의 크기** 를 줄일 수 있다.  

![](/assets/images/가상메모리1.png)  

우선 우리가 실행을 시키고잦 하는 프로세스들을 페이징 과정을 먼저 실행한다. 메인 메모리의 외부 단편화 문제를 해결하여 메모리 낭비를 줄이는 데 페이징을 사용하면 매우 효율적이다. 페이징 과정을 거쳐 특정 단위인 페이지 단위로 프로세스를 자른다. 그러면 여기서 페이지들마다 필요한 부분과 필요 없는 부분으로 나눌 수 있다. 여기서 필요한 페이지만 메모리에 적재학 되면 많은 메모리의 낭비를 막고 필요한 프로세스들을 모두 메인 메모리에서 실행할 수 있게 된다. 이를 요구 페이징이라고 한다.  

---

> 요구 페이징(Demand Paging)  

프로세스의 이미지를 backing store에 저장한다. backing store는 swap device로 하드웨어의 부분인데 페이지를 임시 보관하는 공간이다. 프로세스는 페이지의 조합이기 때문에 필요한 페이지만 메모리에 올린다. 이를 요구되는 페이지만 메모리에 올린다는 의미로 요구 페이징이라고 부른다.  

![](/assets/images/가상메모리2.png)  
Swap out : 어떤 페이지는 backing store로 몰아내고,  
Swap in : 그 빈 공간으로 페이지를 가져온다.  

페이징 기법을 사용할 때 페이지 테이블(PTE)이라는 부분을 놔두게 된다. MMU의 재배치 레지스터를 통해 논리 주소를 물리 주소로 바꾸어 주는 주소 변환 과정을 거쳐 CPU가 프로세스는 연속적으로 할당되어져 있다고 속게 만드는 작업을 한다. 그런데 요구 페이징 기법을 사용하면 페이지가 메모리에 올라와있는 것도 있고 올라가지 않고 backing store에 보관되어 있는 것도 존재한다. 따라서 페이지 테이블을 작성할 때 이를 구분해줄 도구가 필요하다. 그래서 valid 비트 필드를 페이지 테이블에 추가한다. 1과 0의 값으로 메모리에 적재되어 있는지 없는지 구분할 수 있다.  

만약 오류가 발생한다면 오류를 제어할 수 있는 코드를 실행해야한다. CPU에서 해당 메모리를 가져오라고 논리 주소를 보냈는데 페이지 테이블에서 접근하려는 페이지가 메모리에 없다고 표시가 되어 있다. 이는 valid 비트 필드에 의해서 결정된다. 그러면 Backing store에서 해당 페이지를 가져와야한다. 이를 수행하기 위해서 CPU는 잠시 하는 일을 멈추고 운영체제가 나서서 Backing store를 뒤져 필요한 페이지를 메모리에 적재하게 된다. 그리고 valid 비트를 올라와 있다고 바꾸어준다. 이런 현상을 페이지 결함, 페이지 부재(Page Fault)라고 부른다.  

![](/assets/images/가상메모리3.png){: width="120%" height="120%"}     

요구 페이징을 할 때 두 가지의 종류가 있다. 처음부터 모든 페이지를 적재시키지 않고 CPU가 요구할 때 valid를 바꾸어 페이지를 적재하는 방법과 우선 필요할 것 같은 페이지를 적재시키고 필요할 때 다른 페이지를 적재시키는 방법이 있다. 전자는 pure demand paging이고 후자는 prepaging 기법이다. pure 기법을 사용하면 페이지를 요구할 때만 메모리에 적재하므로 메모리의 낭비는 매우 줄일 수 있다. 하지만 요구에 의해 앞선 페이지 부재의 현상을 처리 하려고 하면 많은 부담이 발생한다. 이에 반해 미리 올라와져 있는 prepaging은 처리하는 속도는 빠르겠지만 메모리가 낭비될 수 있도 있다.  
